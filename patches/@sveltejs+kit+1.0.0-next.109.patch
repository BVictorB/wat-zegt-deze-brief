diff --git a/node_modules/@sveltejs/kit/dist/ssr.js b/node_modules/@sveltejs/kit/dist/ssr.js
index 3b1690f..2144d19 100644
--- a/node_modules/@sveltejs/kit/dist/ssr.js
+++ b/node_modules/@sveltejs/kit/dist/ssr.js
@@ -1,300 +1,335 @@
-var chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
-var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
-var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
+var chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$'
+var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g
+var reserved =
+	/^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/
 var escaped$1 = {
-    '<': '\\u003C',
-    '>': '\\u003E',
-    '/': '\\u002F',
-    '\\': '\\\\',
-    '\b': '\\b',
-    '\f': '\\f',
-    '\n': '\\n',
-    '\r': '\\r',
-    '\t': '\\t',
-    '\0': '\\0',
-    '\u2028': '\\u2028',
-    '\u2029': '\\u2029'
-};
-var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join('\0');
+	'<': '\\u003C',
+	'>': '\\u003E',
+	'/': '\\u002F',
+	'\\': '\\\\',
+	'\b': '\\b',
+	'\f': '\\f',
+	'\n': '\\n',
+	'\r': '\\r',
+	'\t': '\\t',
+	'\0': '\\0',
+	'\u2028': '\\u2028',
+	'\u2029': '\\u2029',
+}
+var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join('\0')
 function devalue(value) {
-    var counts = new Map();
-    function walk(thing) {
-        if (typeof thing === 'function') {
-            throw new Error("Cannot stringify a function");
-        }
-        if (counts.has(thing)) {
-            counts.set(thing, counts.get(thing) + 1);
-            return;
-        }
-        counts.set(thing, 1);
-        if (!isPrimitive(thing)) {
-            var type = getType(thing);
-            switch (type) {
-                case 'Number':
-                case 'String':
-                case 'Boolean':
-                case 'Date':
-                case 'RegExp':
-                    return;
-                case 'Array':
-                    thing.forEach(walk);
-                    break;
-                case 'Set':
-                case 'Map':
-                    Array.from(thing).forEach(walk);
-                    break;
-                default:
-                    var proto = Object.getPrototypeOf(thing);
-                    if (proto !== Object.prototype &&
-                        proto !== null &&
-                        Object.getOwnPropertyNames(proto).sort().join('\0') !== objectProtoOwnPropertyNames) {
-                        throw new Error("Cannot stringify arbitrary non-POJOs");
-                    }
-                    if (Object.getOwnPropertySymbols(thing).length > 0) {
-                        throw new Error("Cannot stringify POJOs with symbolic keys");
-                    }
-                    Object.keys(thing).forEach(function (key) { return walk(thing[key]); });
-            }
-        }
-    }
-    walk(value);
-    var names = new Map();
-    Array.from(counts)
-        .filter(function (entry) { return entry[1] > 1; })
-        .sort(function (a, b) { return b[1] - a[1]; })
-        .forEach(function (entry, i) {
-        names.set(entry[0], getName(i));
-    });
-    function stringify(thing) {
-        if (names.has(thing)) {
-            return names.get(thing);
-        }
-        if (isPrimitive(thing)) {
-            return stringifyPrimitive(thing);
-        }
-        var type = getType(thing);
-        switch (type) {
-            case 'Number':
-            case 'String':
-            case 'Boolean':
-                return "Object(" + stringify(thing.valueOf()) + ")";
-            case 'RegExp':
-                return "new RegExp(" + stringifyString(thing.source) + ", \"" + thing.flags + "\")";
-            case 'Date':
-                return "new Date(" + thing.getTime() + ")";
-            case 'Array':
-                var members = thing.map(function (v, i) { return i in thing ? stringify(v) : ''; });
-                var tail = thing.length === 0 || (thing.length - 1 in thing) ? '' : ',';
-                return "[" + members.join(',') + tail + "]";
-            case 'Set':
-            case 'Map':
-                return "new " + type + "([" + Array.from(thing).map(stringify).join(',') + "])";
-            default:
-                var obj = "{" + Object.keys(thing).map(function (key) { return safeKey(key) + ":" + stringify(thing[key]); }).join(',') + "}";
-                var proto = Object.getPrototypeOf(thing);
-                if (proto === null) {
-                    return Object.keys(thing).length > 0
-                        ? "Object.assign(Object.create(null)," + obj + ")"
-                        : "Object.create(null)";
-                }
-                return obj;
-        }
-    }
-    var str = stringify(value);
-    if (names.size) {
-        var params_1 = [];
-        var statements_1 = [];
-        var values_1 = [];
-        names.forEach(function (name, thing) {
-            params_1.push(name);
-            if (isPrimitive(thing)) {
-                values_1.push(stringifyPrimitive(thing));
-                return;
-            }
-            var type = getType(thing);
-            switch (type) {
-                case 'Number':
-                case 'String':
-                case 'Boolean':
-                    values_1.push("Object(" + stringify(thing.valueOf()) + ")");
-                    break;
-                case 'RegExp':
-                    values_1.push(thing.toString());
-                    break;
-                case 'Date':
-                    values_1.push("new Date(" + thing.getTime() + ")");
-                    break;
-                case 'Array':
-                    values_1.push("Array(" + thing.length + ")");
-                    thing.forEach(function (v, i) {
-                        statements_1.push(name + "[" + i + "]=" + stringify(v));
-                    });
-                    break;
-                case 'Set':
-                    values_1.push("new Set");
-                    statements_1.push(name + "." + Array.from(thing).map(function (v) { return "add(" + stringify(v) + ")"; }).join('.'));
-                    break;
-                case 'Map':
-                    values_1.push("new Map");
-                    statements_1.push(name + "." + Array.from(thing).map(function (_a) {
-                        var k = _a[0], v = _a[1];
-                        return "set(" + stringify(k) + ", " + stringify(v) + ")";
-                    }).join('.'));
-                    break;
-                default:
-                    values_1.push(Object.getPrototypeOf(thing) === null ? 'Object.create(null)' : '{}');
-                    Object.keys(thing).forEach(function (key) {
-                        statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
-                    });
-            }
-        });
-        statements_1.push("return " + str);
-        return "(function(" + params_1.join(',') + "){" + statements_1.join(';') + "}(" + values_1.join(',') + "))";
-    }
-    else {
-        return str;
-    }
+	var counts = new Map()
+	function walk(thing) {
+		if (typeof thing === 'function') {
+			throw new Error('Cannot stringify a function')
+		}
+		if (counts.has(thing)) {
+			counts.set(thing, counts.get(thing) + 1)
+			return
+		}
+		counts.set(thing, 1)
+		if (!isPrimitive(thing)) {
+			var type = getType(thing)
+			switch (type) {
+				case 'Number':
+				case 'String':
+				case 'Boolean':
+				case 'Date':
+				case 'RegExp':
+					return
+				case 'Array':
+					thing.forEach(walk)
+					break
+				case 'Set':
+				case 'Map':
+					Array.from(thing).forEach(walk)
+					break
+				default:
+					var proto = Object.getPrototypeOf(thing)
+					if (
+						proto !== Object.prototype &&
+						proto !== null &&
+						Object.getOwnPropertyNames(proto).sort().join('\0') !== objectProtoOwnPropertyNames
+					) {
+						throw new Error('Cannot stringify arbitrary non-POJOs')
+					}
+					if (Object.getOwnPropertySymbols(thing).length > 0) {
+						throw new Error('Cannot stringify POJOs with symbolic keys')
+					}
+					Object.keys(thing).forEach(function (key) {
+						return walk(thing[key])
+					})
+			}
+		}
+	}
+	walk(value)
+	var names = new Map()
+	Array.from(counts)
+		.filter(function (entry) {
+			return entry[1] > 1
+		})
+		.sort(function (a, b) {
+			return b[1] - a[1]
+		})
+		.forEach(function (entry, i) {
+			names.set(entry[0], getName(i))
+		})
+	function stringify(thing) {
+		if (names.has(thing)) {
+			return names.get(thing)
+		}
+		if (isPrimitive(thing)) {
+			return stringifyPrimitive(thing)
+		}
+		var type = getType(thing)
+		switch (type) {
+			case 'Number':
+			case 'String':
+			case 'Boolean':
+				return 'Object(' + stringify(thing.valueOf()) + ')'
+			case 'RegExp':
+				return 'new RegExp(' + stringifyString(thing.source) + ', "' + thing.flags + '")'
+			case 'Date':
+				return 'new Date(' + thing.getTime() + ')'
+			case 'Array':
+				var members = thing.map(function (v, i) {
+					return i in thing ? stringify(v) : ''
+				})
+				var tail = thing.length === 0 || thing.length - 1 in thing ? '' : ','
+				return '[' + members.join(',') + tail + ']'
+			case 'Set':
+			case 'Map':
+				return 'new ' + type + '([' + Array.from(thing).map(stringify).join(',') + '])'
+			default:
+				var obj =
+					'{' +
+					Object.keys(thing)
+						.map(function (key) {
+							return safeKey(key) + ':' + stringify(thing[key])
+						})
+						.join(',') +
+					'}'
+				var proto = Object.getPrototypeOf(thing)
+				if (proto === null) {
+					return Object.keys(thing).length > 0
+						? 'Object.assign(Object.create(null),' + obj + ')'
+						: 'Object.create(null)'
+				}
+				return obj
+		}
+	}
+	var str = stringify(value)
+	if (names.size) {
+		var params_1 = []
+		var statements_1 = []
+		var values_1 = []
+		names.forEach(function (name, thing) {
+			params_1.push(name)
+			if (isPrimitive(thing)) {
+				values_1.push(stringifyPrimitive(thing))
+				return
+			}
+			var type = getType(thing)
+			switch (type) {
+				case 'Number':
+				case 'String':
+				case 'Boolean':
+					values_1.push('Object(' + stringify(thing.valueOf()) + ')')
+					break
+				case 'RegExp':
+					values_1.push(thing.toString())
+					break
+				case 'Date':
+					values_1.push('new Date(' + thing.getTime() + ')')
+					break
+				case 'Array':
+					values_1.push('Array(' + thing.length + ')')
+					thing.forEach(function (v, i) {
+						statements_1.push(name + '[' + i + ']=' + stringify(v))
+					})
+					break
+				case 'Set':
+					values_1.push('new Set')
+					statements_1.push(
+						name +
+							'.' +
+							Array.from(thing)
+								.map(function (v) {
+									return 'add(' + stringify(v) + ')'
+								})
+								.join('.')
+					)
+					break
+				case 'Map':
+					values_1.push('new Map')
+					statements_1.push(
+						name +
+							'.' +
+							Array.from(thing)
+								.map(function (_a) {
+									var k = _a[0],
+										v = _a[1]
+									return 'set(' + stringify(k) + ', ' + stringify(v) + ')'
+								})
+								.join('.')
+					)
+					break
+				default:
+					values_1.push(Object.getPrototypeOf(thing) === null ? 'Object.create(null)' : '{}')
+					Object.keys(thing).forEach(function (key) {
+						statements_1.push('' + name + safeProp(key) + '=' + stringify(thing[key]))
+					})
+			}
+		})
+		statements_1.push('return ' + str)
+		return (
+			'(function(' +
+			params_1.join(',') +
+			'){' +
+			statements_1.join(';') +
+			'}(' +
+			values_1.join(',') +
+			'))'
+		)
+	} else {
+		return str
+	}
 }
 function getName(num) {
-    var name = '';
-    do {
-        name = chars[num % chars.length] + name;
-        num = ~~(num / chars.length) - 1;
-    } while (num >= 0);
-    return reserved.test(name) ? name + "_" : name;
+	var name = ''
+	do {
+		name = chars[num % chars.length] + name
+		num = ~~(num / chars.length) - 1
+	} while (num >= 0)
+	return reserved.test(name) ? name + '_' : name
 }
 function isPrimitive(thing) {
-    return Object(thing) !== thing;
+	return Object(thing) !== thing
 }
 function stringifyPrimitive(thing) {
-    if (typeof thing === 'string')
-        return stringifyString(thing);
-    if (thing === void 0)
-        return 'void 0';
-    if (thing === 0 && 1 / thing < 0)
-        return '-0';
-    var str = String(thing);
-    if (typeof thing === 'number')
-        return str.replace(/^(-)?0\./, '$1.');
-    return str;
+	if (typeof thing === 'string') return stringifyString(thing)
+	if (thing === void 0) return 'void 0'
+	if (thing === 0 && 1 / thing < 0) return '-0'
+	var str = String(thing)
+	if (typeof thing === 'number') return str.replace(/^(-)?0\./, '$1.')
+	return str
 }
 function getType(thing) {
-    return Object.prototype.toString.call(thing).slice(8, -1);
+	return Object.prototype.toString.call(thing).slice(8, -1)
 }
 function escapeUnsafeChar(c) {
-    return escaped$1[c] || c;
+	return escaped$1[c] || c
 }
 function escapeUnsafeChars(str) {
-    return str.replace(unsafeChars, escapeUnsafeChar);
+	return str.replace(unsafeChars, escapeUnsafeChar)
 }
 function safeKey(key) {
-    return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
+	return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key))
 }
 function safeProp(key) {
-    return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
+	return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key)
+		? '.' + key
+		: '[' + escapeUnsafeChars(JSON.stringify(key)) + ']'
 }
 function stringifyString(str) {
-    var result = '"';
-    for (var i = 0; i < str.length; i += 1) {
-        var char = str.charAt(i);
-        var code = char.charCodeAt(0);
-        if (char === '"') {
-            result += '\\"';
-        }
-        else if (char in escaped$1) {
-            result += escaped$1[char];
-        }
-        else if (code >= 0xd800 && code <= 0xdfff) {
-            var next = str.charCodeAt(i + 1);
-            // If this is the beginning of a [high, low] surrogate pair,
-            // add the next two characters, otherwise escape
-            if (code <= 0xdbff && (next >= 0xdc00 && next <= 0xdfff)) {
-                result += char + str[++i];
-            }
-            else {
-                result += "\\u" + code.toString(16).toUpperCase();
-            }
-        }
-        else {
-            result += char;
-        }
-    }
-    result += '"';
-    return result;
+	var result = '"'
+	for (var i = 0; i < str.length; i += 1) {
+		var char = str.charAt(i)
+		var code = char.charCodeAt(0)
+		if (char === '"') {
+			result += '\\"'
+		} else if (char in escaped$1) {
+			result += escaped$1[char]
+		} else if (code >= 0xd800 && code <= 0xdfff) {
+			var next = str.charCodeAt(i + 1)
+			// If this is the beginning of a [high, low] surrogate pair,
+			// add the next two characters, otherwise escape
+			if (code <= 0xdbff && next >= 0xdc00 && next <= 0xdfff) {
+				result += char + str[++i]
+			} else {
+				result += '\\u' + code.toString(16).toUpperCase()
+			}
+		} else {
+			result += char
+		}
+	}
+	result += '"'
+	return result
 }
 
-function noop() { }
+function noop() {}
 function safe_not_equal(a, b) {
-    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
+	return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function'
 }
 
-const subscriber_queue = [];
+const subscriber_queue = []
 /**
  * Create a `Writable` store that allows both updating and reading by subscription.
  * @param {*=}value initial value
  * @param {StartStopNotifier=}start start and stop notifications for subscriptions
  */
 function writable(value, start = noop) {
-    let stop;
-    const subscribers = [];
-    function set(new_value) {
-        if (safe_not_equal(value, new_value)) {
-            value = new_value;
-            if (stop) { // store is ready
-                const run_queue = !subscriber_queue.length;
-                for (let i = 0; i < subscribers.length; i += 1) {
-                    const s = subscribers[i];
-                    s[1]();
-                    subscriber_queue.push(s, value);
-                }
-                if (run_queue) {
-                    for (let i = 0; i < subscriber_queue.length; i += 2) {
-                        subscriber_queue[i][0](subscriber_queue[i + 1]);
-                    }
-                    subscriber_queue.length = 0;
-                }
-            }
-        }
-    }
-    function update(fn) {
-        set(fn(value));
-    }
-    function subscribe(run, invalidate = noop) {
-        const subscriber = [run, invalidate];
-        subscribers.push(subscriber);
-        if (subscribers.length === 1) {
-            stop = start(set) || noop;
-        }
-        run(value);
-        return () => {
-            const index = subscribers.indexOf(subscriber);
-            if (index !== -1) {
-                subscribers.splice(index, 1);
-            }
-            if (subscribers.length === 0) {
-                stop();
-                stop = null;
-            }
-        };
-    }
-    return { set, update, subscribe };
+	let stop
+	const subscribers = []
+	function set(new_value) {
+		if (safe_not_equal(value, new_value)) {
+			value = new_value
+			if (stop) {
+				// store is ready
+				const run_queue = !subscriber_queue.length
+				for (let i = 0; i < subscribers.length; i += 1) {
+					const s = subscribers[i]
+					s[1]()
+					subscriber_queue.push(s, value)
+				}
+				if (run_queue) {
+					for (let i = 0; i < subscriber_queue.length; i += 2) {
+						subscriber_queue[i][0](subscriber_queue[i + 1])
+					}
+					subscriber_queue.length = 0
+				}
+			}
+		}
+	}
+	function update(fn) {
+		set(fn(value))
+	}
+	function subscribe(run, invalidate = noop) {
+		const subscriber = [run, invalidate]
+		subscribers.push(subscriber)
+		if (subscribers.length === 1) {
+			stop = start(set) || noop
+		}
+		run(value)
+		return () => {
+			const index = subscribers.indexOf(subscriber)
+			if (index !== -1) {
+				subscribers.splice(index, 1)
+			}
+			if (subscribers.length === 0) {
+				stop()
+				stop = null
+			}
+		}
+	}
+	return { set, update, subscribe }
 }
 
 /** @param {string | Uint8Array} value */
 function hash(value) {
-	let hash = 5381;
-	let i = value.length;
+	let hash = 5381
+	let i = value.length
 
 	if (typeof value === 'string') {
-		while (i) hash = (hash * 33) ^ value.charCodeAt(--i);
+		while (i) hash = (hash * 33) ^ value.charCodeAt(--i)
 	} else {
-		while (i) hash = (hash * 33) ^ value[--i];
+		while (i) hash = (hash * 33) ^ value[--i]
 	}
 
-	return (hash >>> 0).toString(36);
+	return (hash >>> 0).toString(36)
 }
 
-const s$1 = JSON.stringify;
+const s$1 = JSON.stringify
 
 // TODO rename this function/module
 
@@ -309,81 +344,73 @@ const s$1 = JSON.stringify;
  *   page: import('types/page').Page
  * }} opts
  */
-async function render_response({
-	options,
-	$session,
-	page_config,
-	status,
-	error,
-	branch,
-	page
-}) {
-	const css = new Set(options.entry.css);
-	const js = new Set(options.entry.js);
-	const styles = new Set();
+async function render_response({ options, $session, page_config, status, error, branch, page }) {
+	const css = new Set(options.entry.css)
+	const js = new Set(options.entry.js)
+	const styles = new Set()
 
 	/** @type {Array<{ url: string, body: string, json: string }>} */
-	const serialized_data = [];
+	const serialized_data = []
 
-	let rendered;
+	let rendered
 
-	let is_private = false;
-	let maxage;
+	let is_private = false
+	let maxage
 
 	if (error) {
-		error.stack = options.get_stack(error);
+		error.stack = options.get_stack(error)
 	}
 
 	if (branch) {
 		branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
-			if (node.css) node.css.forEach((url) => css.add(url));
-			if (node.js) node.js.forEach((url) => js.add(url));
-			if (node.styles) node.styles.forEach((content) => styles.add(content));
+			if (node.css) node.css.forEach(url => css.add(url))
+			if (node.js) node.js.forEach(url => js.add(url))
+			if (node.styles) node.styles.forEach(content => styles.add(content))
 
 			// TODO probably better if `fetched` wasn't populated unless `hydrate`
-			if (fetched && page_config.hydrate) serialized_data.push(...fetched);
+			if (fetched && page_config.hydrate) serialized_data.push(...fetched)
 
-			if (uses_credentials) is_private = true;
+			if (uses_credentials) is_private = true
 
-			maxage = loaded.maxage;
-		});
+			maxage = loaded.maxage
+		})
 
-		const session = writable($session);
+		const session = writable($session)
 
 		/** @type {Record<string, any>} */
 		const props = {
 			stores: {
 				page: writable(null),
 				navigating: writable(null),
-				session
+				session,
 			},
 			page,
-			components: branch.map(({ node }) => node.module.default)
-		};
+			components: branch.map(({ node }) => node.module.default),
+		}
 
 		// props_n (instead of props[n]) makes it easy to avoid
 		// unnecessary updates for layout components
 		for (let i = 0; i < branch.length; i += 1) {
-			props[`props_${i}`] = await branch[i].loaded.props;
+			props[`props_${i}`] = await branch[i].loaded.props
 		}
 
-		let session_tracking_active = false;
+		let session_tracking_active = false
 		const unsubscribe = session.subscribe(() => {
-			if (session_tracking_active) is_private = true;
-		});
-		session_tracking_active = true;
+			if (session_tracking_active) is_private = true
+		})
+		session_tracking_active = true
 
 		try {
-			rendered = options.root.render(props);
+			rendered = options.root.render(props)
 		} finally {
-			unsubscribe();
+			unsubscribe()
 		}
 	} else {
-		rendered = { head: '', html: '', css: { code: '', map: null } };
+		rendered = { head: '', html: '', css: { code: '', map: null } }
 	}
 
-	const include_js = page_config.router || page_config.hydrate;
-	if (!include_js) js.clear();
+	const include_js = page_config.router || page_config.hydrate
+	if (!include_js) js.clear()
 
 	// TODO strip the AMP stuff out of the build if not relevant
 	const links = options.amp
@@ -391,18 +418,18 @@ async function render_response({
 			? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join('\n')}</style>`
 			: ''
 		: [
-				...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
-				...Array.from(css).map((dep) => `<link rel="stylesheet" href="${dep}">`)
-		  ].join('\n\t\t');
+				...Array.from(js).map(dep => `<link rel="modulepreload" href="${dep}">`),
+				...Array.from(css).map(dep => `<link rel="stylesheet" href="${dep}">`),
+		  ].join('\n\t\t')
 
 	/** @type {string} */
-	let init = '';
+	let init = ''
 
 	if (options.amp) {
 		init = `
 		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
 		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
-		<script async src="https://cdn.ampproject.org/v0.js"></script>`;
+		<script async src="https://cdn.ampproject.org/v0.js"></script>`
 	} else if (include_js) {
 		// prettier-ignore
 		init = `<script type="module">
@@ -442,8 +469,8 @@ async function render_response({
 			? `<style data-svelte>${Array.from(styles).join('\n')}</style>`
 			: '',
 		links,
-		init
-	].join('\n\n\t\t');
+		init,
+	].join('\n\n\t\t')
 
 	const body = options.amp
 		? rendered.html
@@ -453,29 +480,29 @@ async function render_response({
 				.map(({ url, body, json }) => {
 					return body
 						? `<script type="svelte-data" url="${url}" body="${hash(body)}">${json}</script>`
-						: `<script type="svelte-data" url="${url}">${json}</script>`;
+						: `<script type="svelte-data" url="${url}">${json}</script>`
 				})
 				.join('\n\n\t\t\t')}
-		`.replace(/^\t{2}/gm, '');
+		`.replace(/^\t{2}/gm, '')
 
 	/** @type {import('types/helper').Headers} */
 	const headers = {
-		'content-type': 'text/html'
-	};
+		'content-type': 'text/html',
+	}
 
 	if (maxage) {
-		headers['cache-control'] = `${is_private ? 'private' : 'public'}, max-age=${maxage}`;
+		headers['cache-control'] = `${is_private ? 'private' : 'public'}, max-age=${maxage}`
 	}
 
 	if (!options.floc) {
-		headers['permissions-policy'] = 'interest-cohort=()';
+		headers['permissions-policy'] = 'interest-cohort=()'
 	}
 
 	return {
 		status,
 		headers,
-		body: options.template({ head, body })
-	};
+		body: options.template({ head, body }),
+	}
 }
 
 /**
@@ -484,10 +511,10 @@ async function render_response({
  */
 function try_serialize(data, fail) {
 	try {
-		return devalue(data);
+		return devalue(data)
 	} catch (err) {
-		if (fail) fail(err);
-		return null;
+		if (fail) fail(err)
+		return null
 	}
 }
 
@@ -495,16 +522,16 @@ function try_serialize(data, fail) {
 
 /** @param {Error} error */
 function serialize_error(error) {
-	if (!error) return null;
-	let serialized = try_serialize(error);
+	if (!error) return null
+	let serialized = try_serialize(error)
 	if (!serialized) {
-		const { name, message, stack } = error;
-		serialized = try_serialize({ name, message, stack });
+		const { name, message, stack } = error
+		serialized = try_serialize({ name, message, stack })
 	}
 	if (!serialized) {
-		serialized = '{}';
+		serialized = '{}'
 	}
-	return serialized;
+	return serialized
 }
 
 /**
@@ -515,24 +542,24 @@ function normalize(loaded) {
 	// TODO should this behaviour be dev-only?
 
 	if (loaded.error) {
-		const error = typeof loaded.error === 'string' ? new Error(loaded.error) : loaded.error;
-		const status = loaded.status;
+		const error = typeof loaded.error === 'string' ? new Error(loaded.error) : loaded.error
+		const status = loaded.status
 
 		if (!(error instanceof Error)) {
 			return {
 				status: 500,
 				error: new Error(
 					`"error" property returned from load() must be a string or instance of Error, received type "${typeof error}"`
-				)
-			};
+				),
+			}
 		}
 
 		if (!status || status < 400 || status > 599) {
-			console.warn('"error" returned from load() without a valid status code — defaulting to 500');
-			return { status: 500, error };
+			console.warn('"error" returned from load() without a valid status code — defaulting to 500')
+			return { status: 500, error }
 		}
 
-		return { status, error };
+		return { status, error }
 	}
 
 	if (loaded.redirect) {
@@ -541,19 +568,19 @@ function normalize(loaded) {
 				status: 500,
 				error: new Error(
 					'"redirect" property returned from load() must be accompanied by a 3xx status code'
-				)
-			};
+				),
+			}
 		}
 
 		if (typeof loaded.redirect !== 'string') {
 			return {
 				status: 500,
-				error: new Error('"redirect" property returned from load() must be a string')
-			};
+				error: new Error('"redirect" property returned from load() must be a string'),
+			}
 		}
 	}
 
-	return /** @type {import('types/internal').NormalizedLoadOutput} */ (loaded);
+	return /** @type {import('types/internal').NormalizedLoadOutput} */ (loaded)
 }
 
 /**
@@ -561,22 +588,22 @@ function normalize(loaded) {
  * @param {string} path
  */
 function resolve(base, path) {
-	const baseparts = path[0] === '/' ? [] : base.slice(1).split('/');
-	const pathparts = path[0] === '/' ? path.slice(1).split('/') : path.split('/');
+	const baseparts = path[0] === '/' ? [] : base.slice(1).split('/')
+	const pathparts = path[0] === '/' ? path.slice(1).split('/') : path.split('/')
 
-	baseparts.pop();
+	baseparts.pop()
 
 	for (let i = 0; i < pathparts.length; i += 1) {
-		const part = pathparts[i];
-		if (part === '.') continue;
-		else if (part === '..') baseparts.pop();
-		else baseparts.push(part);
+		const part = pathparts[i]
+		if (part === '.') continue
+		else if (part === '..') baseparts.pop()
+		else baseparts.push(part)
 	}
 
-	return `/${baseparts.join('/')}`;
+	return `/${baseparts.join('/')}`
 }
 
-const s = JSON.stringify;
+const s = JSON.stringify
 
 /**
  *
@@ -608,28 +635,28 @@ async function load_node({
 	is_leaf,
 	is_error,
 	status,
-	error
+	error,
 }) {
-	const { module } = node;
+	const { module } = node
 
-	let uses_credentials = false;
+	let uses_credentials = false
 
 	/** @type {Array<{
 	 *   url: string;
 	 *   body: string;
 	 *   json: string;
 	 * }>} */
-	const fetched = [];
+	const fetched = []
 
-	let loaded;
+	let loaded
 
 	if (module.load) {
 		/** @type {import('types/page').LoadInput | import('types/page').ErrorLoadInput} */
 		const load_input = {
 			page,
 			get session() {
-				uses_credentials = true;
-				return $session;
+				uses_credentials = true
+				return $session
 			},
 			/**
 			 * @param {RequestInfo} resource
@@ -637,12 +664,12 @@ async function load_node({
 			 */
 			fetch: async (resource, opts = {}) => {
 				/** @type {string} */
-				let url;
+				let url
 
 				if (typeof resource === 'string') {
-					url = resource;
+					url = resource
 				} else {
-					url = resource.url;
+					url = resource.url
 
 					opts = {
 						method: resource.method,
@@ -654,39 +681,39 @@ async function load_node({
 						redirect: resource.redirect,
 						referrer: resource.referrer,
 						integrity: resource.integrity,
-						...opts
-					};
+						...opts,
+					}
 				}
 
 				if (options.read && url.startsWith(options.paths.assets)) {
 					// when running `start`, or prerendering, `assets` should be
 					// config.kit.paths.assets, but we should still be able to fetch
 					// assets directly from `static`
-					url = url.replace(options.paths.assets, '');
+					url = url.replace(options.paths.assets, '')
 				}
 
 				if (url.startsWith('//')) {
-					throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
+					throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`)
 				}
 
-				let response;
+				let response
 
 				if (/^[a-zA-Z]+:/.test(url)) {
 					// external fetch
-					response = await fetch(url, /** @type {RequestInit} */ (opts));
+					response = await fetch(url, /** @type {RequestInit} */ (opts))
 				} else {
-					const [path, search] = url.split('?');
+					const [path, search] = url.split('?')
 
 					// otherwise we're dealing with an internal fetch
-					const resolved = resolve(request.path, path);
+					const resolved = resolve(request.path, path)
 
 					// handle fetch requests for static assets. e.g. prebaked data, etc.
 					// we need to support everything the browser's fetch supports
-					const filename = resolved.slice(1);
-					const filename_html = `${filename}/index.html`; // path may also match path/index.html
+					const filename = resolved.slice(1)
+					const filename_html = `${filename}/index.html` // path may also match path/index.html
 					const asset = options.manifest.assets.find(
-						(d) => d.file === filename || d.file === filename_html
-					);
+						d => d.file === filename || d.file === filename_html
+					)
 
 					if (asset) {
 						// we don't have a running server while prerendering because jumping between
@@ -694,29 +721,29 @@ async function load_node({
 						if (options.read) {
 							response = new Response(options.read(asset.file), {
 								headers: {
-									'content-type': asset.type
-								}
-							});
+									'content-type': asset.type,
+								},
+							})
 						} else {
 							// TODO we need to know what protocol to use
 							response = await fetch(
 								`http://${page.host}/${asset.file}`,
 								/** @type {RequestInit} */ (opts)
-							);
+							)
 						}
 					}
 
 					if (!response) {
-						const headers = /** @type {import('types/helper').Headers} */ ({ ...opts.headers });
+						const headers = /** @type {import('types/helper').Headers} */ ({ ...opts.headers })
 
 						// TODO: fix type https://github.com/node-fetch/node-fetch/issues/1113
 						if (opts.credentials !== 'omit') {
-							uses_credentials = true;
+							uses_credentials = true
 
-							headers.cookie = request.headers.cookie;
+							headers.cookie = request.headers.cookie
 
 							if (!headers.authorization) {
-								headers.authorization = request.headers.authorization;
+								headers.authorization = request.headers.authorization
 							}
 						}
 
@@ -725,7 +752,7 @@ async function load_node({
 							// Blob, BufferSource, FormData, URLSearchParams, USVString, or ReadableStream object.
 							// non-string bodies are irksome to deal with, but luckily aren't particularly useful
 							// in this context anyway, so we take the easy route and ban them
-							throw new Error('Request body must be a string');
+							throw new Error('Request body must be a string')
 						}
 
 						const rendered = await respond(
@@ -735,24 +762,24 @@ async function load_node({
 								headers,
 								path: resolved,
 								rawBody: /** @type {string} */ (opts.body),
-								query: new URLSearchParams(search)
+								query: new URLSearchParams(search),
 							},
 							options,
 							{
 								fetched: url,
-								initiator: route
+								initiator: route,
 							}
-						);
+						)
 
 						if (rendered) {
 							if (state.prerender) {
-								state.prerender.dependencies.set(resolved, rendered);
+								state.prerender.dependencies.set(resolved, rendered)
 							}
 
 							response = new Response(rendered.body, {
 								status: rendered.status,
-								headers: rendered.headers
-							});
+								headers: rendered.headers,
+							})
 						}
 					}
 				}
@@ -761,12 +788,12 @@ async function load_node({
 					const proxy = new Proxy(response, {
 						get(response, key, receiver) {
 							async function text() {
-								const body = await response.text();
+								const body = await response.text()
 
 								/** @type {import('types/helper').Headers} */
-								const headers = {};
+								const headers = {}
 								for (const [key, value] of response.headers) {
-									if (key !== 'etag' && key !== 'set-cookie') headers[key] = value;
+									if (key !== 'etag' && key !== 'set-cookie') headers[key] = value
 								}
 
 								if (!opts.body || typeof opts.body === 'string') {
@@ -778,59 +805,60 @@ async function load_node({
 									});
 								}
 
-								return body;
+								return body
 							}
 
 							if (key === 'text') {
-								return text;
+								return text
 							}
 
 							if (key === 'json') {
 								return async () => {
-									return JSON.parse(await text());
-								};
+									return JSON.parse(await text())
+								}
 							}
 
 							// TODO arrayBuffer?
 
-							return Reflect.get(response, key, response);
-						}
-					});
+							return Reflect.get(response, key, response)
+						},
+					})
 
-					return proxy;
+					return proxy
 				}
 
 				return (
 					response ||
 					new Response('Not found', {
-						status: 404
+						status: 404,
 					})
-				);
+				)
 			},
-			context: { ...context }
-		};
+			context: { ...context },
+		}
 
 		if (is_error) {
-			/** @type {import('types/page').ErrorLoadInput} */ (load_input).status = status;
-			/** @type {import('types/page').ErrorLoadInput} */ (load_input).error = error;
+			/** @type {import('types/page').ErrorLoadInput} */ load_input.status = status
+			/** @type {import('types/page').ErrorLoadInput} */
+			load_input.error = error
 		}
 
-		loaded = await module.load.call(null, load_input);
+		loaded = await module.load.call(null, load_input)
 	} else {
-		loaded = {};
+		loaded = {}
 	}
 
 	// if leaf node (i.e. page component) has a load function
 	// that returns nothing, we fall through to the next one
-	if (!loaded && is_leaf && !is_error) return;
+	if (!loaded && is_leaf && !is_error) return
 
 	return {
 		node,
 		loaded: normalize(loaded),
 		context: loaded.context || context,
 		fetched,
-		uses_credentials
-	};
+		uses_credentials,
+	}
 }
 
 /** @type {Record<string, string>} */
@@ -846,38 +874,38 @@ const escaped = {
 	'\t': '\\t',
 	'\0': '\\0',
 	'\u2028': '\\u2028',
-	'\u2029': '\\u2029'
-};
+	'\u2029': '\\u2029',
+}
 
 /** @param {string} str */
 function escape(str) {
-	let result = '"';
+	let result = '"'
 
 	for (let i = 0; i < str.length; i += 1) {
-		const char = str.charAt(i);
-		const code = char.charCodeAt(0);
+		const char = str.charAt(i)
+		const code = char.charCodeAt(0)
 
 		if (char === '"') {
-			result += '\\"';
+			result += '\\"'
 		} else if (char in escaped) {
-			result += escaped[char];
+			result += escaped[char]
 		} else if (code >= 0xd800 && code <= 0xdfff) {
-			const next = str.charCodeAt(i + 1);
+			const next = str.charCodeAt(i + 1)
 
 			// If this is the beginning of a [high, low] surrogate pair,
 			// add the next two characters, otherwise escape
 			if (code <= 0xdbff && next >= 0xdc00 && next <= 0xdfff) {
-				result += char + str[++i];
+				result += char + str[++i]
 			} else {
-				result += `\\u${code.toString(16).toUpperCase()}`;
+				result += `\\u${code.toString(16).toUpperCase()}`
 			}
 		} else {
-			result += char;
+			result += char
 		}
 	}
 
-	result += '"';
-	return result;
+	result += '"'
+	return result
 }
 
 /**
@@ -891,15 +919,15 @@ function escape(str) {
  * }} opts
  */
 async function respond_with_error({ request, options, state, $session, status, error }) {
-	const default_layout = await options.load_component(options.manifest.layout);
-	const default_error = await options.load_component(options.manifest.error);
+	const default_layout = await options.load_component(options.manifest.layout)
+	const default_error = await options.load_component(options.manifest.error)
 
 	const page = {
 		host: request.host,
 		path: request.path,
 		query: request.query,
-		params: {}
-	};
+		params: {},
+	}
 
 	const loaded = await load_node({
 		request,
@@ -911,8 +939,8 @@ async function respond_with_error({ request, options, state, $session, status, e
 		$session,
 		context: {},
 		is_leaf: false,
-		is_error: false
-	});
+		is_error: false,
+	})
 
 	const branch = [
 		loaded,
@@ -928,9 +956,9 @@ async function respond_with_error({ request, options, state, $session, status, e
 			is_leaf: false,
 			is_error: true,
 			status,
-			error
-		})
-	];
+			error,
+		}),
+	]
 
 	try {
 		return await render_response({
@@ -939,21 +967,21 @@ async function respond_with_error({ request, options, state, $session, status, e
 			page_config: {
 				hydrate: options.hydrate,
 				router: options.router,
-				ssr: options.ssr
+				ssr: options.ssr,
 			},
 			status,
 			error,
 			branch,
-			page
-		});
+			page,
+		})
 	} catch (error) {
-		options.handle_error(error);
+		options.handle_error(error)
 
 		return {
 			status: 500,
 			headers: {},
-			body: error.stack
-		};
+			body: error.stack,
+		}
 	}
 }
 
@@ -970,22 +998,22 @@ async function respond_with_error({ request, options, state, $session, status, e
  * @returns {Promise<import('types/hooks').ServerResponse>}
  */
 async function respond$1({ request, options, state, $session, route }) {
-	const match = route.pattern.exec(request.path);
-	const params = route.params(match);
+	const match = route.pattern.exec(request.path)
+	const params = route.params(match)
 
 	const page = {
 		host: request.host,
 		path: request.path,
 		query: request.query,
-		params
-	};
+		params,
+	}
 
-	let nodes;
+	let nodes
 
 	try {
-		nodes = await Promise.all(route.a.map((id) => id && options.load_component(id)));
+		nodes = await Promise.all(route.a.map(id => id && options.load_component(id)))
 	} catch (error) {
-		options.handle_error(error);
+		options.handle_error(error)
 
 		return await respond_with_error({
 			request,
@@ -993,17 +1021,17 @@ async function respond$1({ request, options, state, $session, route }) {
 			state,
 			$session,
 			status: 500,
-			error
-		});
+			error,
+		})
 	}
 
-	const leaf = nodes[nodes.length - 1].module;
+	const leaf = nodes[nodes.length - 1].module
 
 	const page_config = {
 		ssr: 'ssr' in leaf ? leaf.ssr : options.ssr,
 		router: 'router' in leaf ? leaf.router : options.router,
-		hydrate: 'hydrate' in leaf ? leaf.hydrate : options.hydrate
-	};
+		hydrate: 'hydrate' in leaf ? leaf.hydrate : options.hydrate,
+	}
 
 	if (!leaf.prerender && state.prerender && !state.prerender.all) {
 		// if the page has `export const prerender = true`, continue,
@@ -1011,28 +1039,28 @@ async function respond$1({ request, options, state, $session, route }) {
 		return {
 			status: 204,
 			headers: {},
-			body: null
-		};
+			body: null,
+		}
 	}
 
 	/** @type {Loaded[]} */
-	let branch;
+	let branch
 
 	/** @type {number} */
-	let status = 200;
+	let status = 200
 
 	/** @type {Error} */
-	let error;
+	let error
 
 	ssr: if (page_config.ssr) {
-		let context = {};
-		branch = [];
+		let context = {}
+		branch = []
 
 		for (let i = 0; i < nodes.length; i += 1) {
-			const node = nodes[i];
+			const node = nodes[i]
 
 			/** @type {Loaded} */
-			let loaded;
+			let loaded
 
 			if (node) {
 				try {
@@ -1046,41 +1074,41 @@ async function respond$1({ request, options, state, $session, route }) {
 						$session,
 						context,
 						is_leaf: i === nodes.length - 1,
-						is_error: false
-					});
+						is_error: false,
+					})
 
-					if (!loaded) return;
+					if (!loaded) return
 
 					if (loaded.loaded.redirect) {
 						return {
 							status: loaded.loaded.status,
 							headers: {
-								location: encodeURI(loaded.loaded.redirect)
-							}
-						};
+								location: encodeURI(loaded.loaded.redirect),
+							},
+						}
 					}
 
 					if (loaded.loaded.error) {
-						({ status, error } = loaded.loaded);
+						;({ status, error } = loaded.loaded)
 					}
 				} catch (e) {
-					options.handle_error(e);
+					options.handle_error(e)
 
-					status = 500;
-					error = e;
+					status = 500
+					error = e
 				}
 
 				if (error) {
 					while (i--) {
 						if (route.b[i]) {
-							const error_node = await options.load_component(route.b[i]);
-							let error_loaded;
+							const error_node = await options.load_component(route.b[i])
+							let error_loaded
 
 							/** @type {Loaded} */
-							let node_loaded;
-							let j = i;
+							let node_loaded
+							let j = i
 							while (!(node_loaded = branch[j])) {
-								j -= 1;
+								j -= 1
 							}
 
 							try {
@@ -1096,19 +1124,19 @@ async function respond$1({ request, options, state, $session, route }) {
 									is_leaf: false,
 									is_error: true,
 									status,
-									error
-								});
+									error,
+								})
 
 								if (error_loaded.loaded.error) {
-									continue;
+									continue
 								}
 
-								branch = branch.slice(0, j + 1).concat(error_loaded);
-								break ssr;
+								branch = branch.slice(0, j + 1).concat(error_loaded)
+								break ssr
 							} catch (e) {
-								options.handle_error(e);
+								options.handle_error(e)
 
-								continue;
+								continue
 							}
 						}
 					}
@@ -1122,19 +1150,19 @@ async function respond$1({ request, options, state, $session, route }) {
 						state,
 						$session,
 						status,
-						error
-					});
+						error,
+					})
 				}
 			}
 
-			branch.push(loaded);
+			branch.push(loaded)
 
 			if (loaded && loaded.loaded.context) {
 				// TODO come up with better names for stuff
 				context = {
 					...context,
-					...loaded.loaded.context
-				};
+					...loaded.loaded.context,
+				}
 			}
 		}
 	}
@@ -1147,10 +1175,10 @@ async function respond$1({ request, options, state, $session, route }) {
 			status,
 			error,
 			branch: branch && branch.filter(Boolean),
-			page
-		});
+			page,
+		})
 	} catch (error) {
-		options.handle_error(error);
+		options.handle_error(error)
 
 		return await respond_with_error({
 			request,
@@ -1158,8 +1186,8 @@ async function respond$1({ request, options, state, $session, route }) {
 			state,
 			$session,
 			status: 500,
-			error
-		});
+			error,
+		})
 	}
 }
 
@@ -1176,11 +1204,11 @@ async function render_page(request, route, options, state) {
 		return {
 			status: 404,
 			headers: {},
-			body: `Not found: ${request.path}`
-		};
+			body: `Not found: ${request.path}`,
+		}
 	}
 
-	const $session = await options.hooks.getSession(request);
+	const $session = await options.hooks.getSession(request)
 
 	if (route) {
 		const response = await respond$1({
@@ -1188,11 +1216,11 @@ async function render_page(request, route, options, state) {
 			options,
 			state,
 			$session,
-			route
-		});
+			route,
+		})
 
 		if (response) {
-			return response;
+			return response
 		}
 
 		if (state.fetched) {
@@ -1203,8 +1231,8 @@ async function render_page(request, route, options, state) {
 			return {
 				status: 500,
 				headers: {},
-				body: `Bad request in load function: failed to fetch ${state.fetched}`
-			};
+				body: `Bad request in load function: failed to fetch ${state.fetched}`,
+			}
 		}
 	} else {
 		return await respond_with_error({
@@ -1213,21 +1241,21 @@ async function render_page(request, route, options, state) {
 			state,
 			$session,
 			status: 404,
-			error: new Error(`Not found: ${request.path}`)
-		});
+			error: new Error(`Not found: ${request.path}`),
+		})
 	}
 }
 
 /** @param {Record<string, string>} obj */
 function lowercase_keys(obj) {
 	/** @type {Record<string, string>} */
-	const clone = {};
+	const clone = {}
 
 	for (const key in obj) {
-		clone[key.toLowerCase()] = obj[key];
+		clone[key.toLowerCase()] = obj[key]
 	}
 
-	return clone;
+	return clone
 }
 
 /** @param {string} body */
@@ -1235,8 +1263,8 @@ function error(body) {
 	return {
 		status: 500,
 		body,
-		headers: {}
-	};
+		headers: {},
+	}
 }
 
 /**
@@ -1245,60 +1273,60 @@ function error(body) {
  * @returns {Promise<import('types/hooks').ServerResponse>}
  */
 async function render_route(request, route) {
-	const mod = await route.load();
+	const mod = await route.load()
 
 	/** @type {import('types/endpoint').RequestHandler} */
-	const handler = mod[request.method.toLowerCase().replace('delete', 'del')]; // 'delete' is a reserved word
+	const handler = mod[request.method.toLowerCase().replace('delete', 'del')] // 'delete' is a reserved word
 
 	if (handler) {
-		const match = route.pattern.exec(request.path);
-		const params = route.params(match);
+		const match = route.pattern.exec(request.path)
+		const params = route.params(match)
 
-		const response = await handler({ ...request, params });
+		const response = await handler({ ...request, params })
 
 		if (response) {
 			if (typeof response !== 'object') {
 				return error(
 					`Invalid response from route ${request.path}: expected an object, got ${typeof response}`
-				);
+				)
 			}
 
-			let { status = 200, body, headers = {} } = response;
+			let { status = 200, body, headers = {} } = response
 
-			headers = lowercase_keys(headers);
-			const type = headers['content-type'];
+			headers = lowercase_keys(headers)
+			const type = headers['content-type']
 
 			// validation
 			if (type === 'application/octet-stream' && !(body instanceof Uint8Array)) {
 				return error(
 					`Invalid response from route ${request.path}: body must be an instance of Uint8Array if content type is application/octet-stream`
-				);
+				)
 			}
 
 			if (body instanceof Uint8Array && type !== 'application/octet-stream') {
 				return error(
 					`Invalid response from route ${request.path}: Uint8Array body must be accompanied by content-type: application/octet-stream header`
-				);
+				)
 			}
 
 			/** @type {string | Uint8Array} */
-			let normalized_body;
+			let normalized_body
 
 			if (typeof body === 'object' && (!type || type === 'application/json')) {
-				headers = { ...headers, 'content-type': 'application/json' };
-				normalized_body = JSON.stringify(body);
+				headers = { ...headers, 'content-type': 'application/json' }
+				normalized_body = JSON.stringify(body)
 			} else {
-				normalized_body = /** @type {string | Uint8Array} */ (body);
+				normalized_body = /** @type {string | Uint8Array} */ (body)
 			}
 
-			return { status, body: normalized_body, headers };
+			return { status, body: normalized_body, headers }
 		}
 	}
 }
 
 function read_only_form_data() {
 	/** @type {Map<string, string[]>} */
-	const map = new Map();
+	const map = new Map()
 
 	return {
 		/**
@@ -1307,45 +1335,45 @@ function read_only_form_data() {
 		 */
 		append(key, value) {
 			if (map.has(key)) {
-				map.get(key).push(value);
+				map.get(key).push(value)
 			} else {
-				map.set(key, [value]);
+				map.set(key, [value])
 			}
 		},
 
-		data: new ReadOnlyFormData(map)
-	};
+		data: new ReadOnlyFormData(map),
+	}
 }
 
 class ReadOnlyFormData {
 	/** @type {Map<string, string[]>} */
-	#map;
+	#map
 
 	/** @param {Map<string, string[]>} map */
 	constructor(map) {
-		this.#map = map;
+		this.#map = map
 	}
 
 	/** @param {string} key */
 	get(key) {
-		const value = this.#map.get(key);
-		return value && value[0];
+		const value = this.#map.get(key)
+		return value && value[0]
 	}
 
 	/** @param {string} key */
 	getAll(key) {
-		return this.#map.get(key);
+		return this.#map.get(key)
 	}
 
 	/** @param {string} key */
 	has(key) {
-		return this.#map.has(key);
+		return this.#map.has(key)
 	}
 
 	*[Symbol.iterator]() {
 		for (const [key, value] of this.#map) {
 			for (let i = 0; i < value.length; i += 1) {
-				yield [key, value[i]];
+				yield [key, value[i]]
 			}
 		}
 	}
@@ -1353,7 +1381,7 @@ class ReadOnlyFormData {
 	*entries() {
 		for (const [key, value] of this.#map) {
 			for (let i = 0; i < value.length; i += 1) {
-				yield [key, value[i]];
+				yield [key, value[i]]
 			}
 		}
 	}
@@ -1361,7 +1389,7 @@ class ReadOnlyFormData {
 	*keys() {
 		for (const [key, value] of this.#map) {
 			for (let i = 0; i < value.length; i += 1) {
-				yield key;
+				yield key
 			}
 		}
 	}
@@ -1369,7 +1397,7 @@ class ReadOnlyFormData {
 	*values() {
 		for (const [, value] of this.#map) {
 			for (let i = 0; i < value.length; i += 1) {
-				yield value;
+				yield value
 			}
 		}
 	}
@@ -1377,48 +1405,48 @@ class ReadOnlyFormData {
 
 /** @param {import('types/hooks').Incoming} req */
 function parse_body(req) {
-	const raw = req.rawBody;
-	if (!raw) return raw;
+	const raw = req.rawBody
+	if (!raw) return raw
 
-	const [type, ...directives] = req.headers['content-type'].split(/;\s*/);
+	const [type, ...directives] = req.headers['content-type'].split(/;\s*/)
 
 	if (typeof raw === 'string') {
 		switch (type) {
 			case 'text/plain':
-				return raw;
+				return raw
 
 			case 'application/json':
-				return JSON.parse(raw);
+				return JSON.parse(raw)
 
 			case 'application/x-www-form-urlencoded':
-				return get_urlencoded(raw);
+				return get_urlencoded(raw)
 
 			case 'multipart/form-data': {
-				const boundary = directives.find((directive) => directive.startsWith('boundary='));
-				if (!boundary) throw new Error('Missing boundary');
-				return get_multipart(raw, boundary.slice('boundary='.length));
+				const boundary = directives.find(directive => directive.startsWith('boundary='))
+				if (!boundary) throw new Error('Missing boundary')
+				return get_multipart(raw, boundary.slice('boundary='.length))
 			}
 			default:
-				throw new Error(`Invalid Content-Type ${type}`);
+				throw new Error(`Invalid Content-Type ${type}`)
 		}
 	}
 
-	return raw;
+	return raw
 }
 
 /** @param {string} text */
 function get_urlencoded(text) {
-	const { data, append } = read_only_form_data();
+	const { data, append } = read_only_form_data()
 
 	text
 		.replace(/\+/g, ' ')
 		.split('&')
-		.forEach((str) => {
-			const [key, value] = str.split('=');
-			append(decodeURIComponent(key), decodeURIComponent(value));
-		});
+		.forEach(str => {
+			const [key, value] = str.split('=')
+			append(decodeURIComponent(key), decodeURIComponent(value))
+		})
 
-	return data;
+	return data
 }
 
 /**
@@ -1426,57 +1454,52 @@ function get_urlencoded(text) {
  * @param {string} boundary
  */
 function get_multipart(text, boundary) {
-	const parts = text.split(`--${boundary}`);
+	const parts = text.split(`--${boundary}`)
 
 	const nope = () => {
-		throw new Error('Malformed form data');
-	};
+		throw new Error('Malformed form data')
+	}
 
 	if (parts[0] !== '' || parts[parts.length - 1].trim() !== '--') {
-		nope();
+		nope()
 	}
 
-	const { data, append } = read_only_form_data();
+	const { data, append } = read_only_form_data()
 
-	parts.slice(1, -1).forEach((part) => {
-		const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
-		const raw_headers = match[1];
-		const body = match[2].trim();
+	parts.slice(1, -1).forEach(part => {
+		const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part)
+		const raw_headers = match[1]
+		const body = match[2].trim()
 
-		let key;
-		raw_headers.split('\r\n').forEach((str) => {
-			const [raw_header, ...raw_directives] = str.split('; ');
-			let [name, value] = raw_header.split(': ');
+		let key
+		raw_headers.split('\r\n').forEach(str => {
+			const [raw_header, ...raw_directives] = str.split('; ')
+			let [name, value] = raw_header.split(': ')
 
-			name = name.toLowerCase();
+			name = name.toLowerCase()
 
 			/** @type {Record<string, string>} */
-			const directives = {};
-			raw_directives.forEach((raw_directive) => {
-				const [name, value] = raw_directive.split('=');
-				directives[name] = JSON.parse(value); // TODO is this right?
-			});
+			const directives = {}
+			raw_directives.forEach(raw_directive => {
+				const [name, value] = raw_directive.split('=')
+				directives[name] = JSON.parse(value) // TODO is this right?
+			})
 
 			if (name === 'content-disposition') {
-				if (value !== 'form-data') nope();
-
-				if (directives.filename) {
-					// TODO we probably don't want to do this automatically
-					throw new Error('File upload is not yet implemented');
-				}
+				if (value !== 'form-data') nope()
 
 				if (directives.name) {
-					key = directives.name;
+					key = directives.name
 				}
 			}
-		});
+		})
 
-		if (!key) nope();
+		if (!key) nope()
 
-		append(key, body);
-	});
+		append(key, body)
+	})
 
-	return data;
+	return data
 }
 
 /**
@@ -1486,7 +1509,7 @@ function get_multipart(text, boundary) {
  */
 async function respond(incoming, options, state = {}) {
 	if (incoming.path !== '/' && options.trailing_slash !== 'ignore') {
-		const has_trailing_slash = incoming.path.endsWith('/');
+		const has_trailing_slash = incoming.path.endsWith('/')
 
 		if (
 			(has_trailing_slash && options.trailing_slash === 'never') ||
@@ -1494,15 +1517,15 @@ async function respond(incoming, options, state = {}) {
 				options.trailing_slash === 'always' &&
 				!incoming.path.split('/').pop().includes('.'))
 		) {
-			const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + '/';
-			const q = incoming.query.toString();
+			const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + '/'
+			const q = incoming.query.toString()
 
 			return {
 				status: 301,
 				headers: {
-					location: encodeURI(path + (q ? `?${q}` : ''))
-				}
-			};
+					location: encodeURI(path + (q ? `?${q}` : '')),
+				},
+			}
 		}
 	}
 
@@ -1513,9 +1536,9 @@ async function respond(incoming, options, state = {}) {
 				headers: lowercase_keys(incoming.headers),
 				body: parse_body(incoming),
 				params: null,
-				locals: {}
+				locals: {},
 			},
-			render: async (request) => {
+			render: async request => {
 				if (state.prerender && state.prerender.fallback) {
 					return await render_response({
 						options,
@@ -1524,52 +1547,52 @@ async function respond(incoming, options, state = {}) {
 						status: 200,
 						error: null,
 						branch: [],
-						page: null
-					});
+						page: null,
+					})
 				}
 
 				for (const route of options.manifest.routes) {
-					if (!route.pattern.test(request.path)) continue;
+					if (!route.pattern.test(request.path)) continue
 
 					const response =
 						route.type === 'endpoint'
 							? await render_route(request, route)
-							: await render_page(request, route, options, state);
+							: await render_page(request, route, options, state)
 
 					if (response) {
 						// inject ETags for 200 responses
 						if (response.status === 200) {
 							if (!/(no-store|immutable)/.test(response.headers['cache-control'])) {
-								const etag = `"${hash(response.body)}"`;
+								const etag = `"${hash(response.body)}"`
 
 								if (request.headers['if-none-match'] === etag) {
 									return {
 										status: 304,
 										headers: {},
-										body: null
-									};
+										body: null,
+									}
 								}
 
-								response.headers['etag'] = etag;
+								response.headers['etag'] = etag
 							}
 						}
 
-						return response;
+						return response
 					}
 				}
 
-				return await render_page(request, null, options, state);
-			}
-		});
+				return await render_page(request, null, options, state)
+			},
+		})
 	} catch (e) {
-		options.handle_error(e);
+		options.handle_error(e)
 
 		return {
 			status: 500,
 			headers: {},
-			body: options.dev ? e.stack : e.message
-		};
+			body: options.dev ? e.stack : e.message,
+		}
 	}
 }
 
-export { respond };
+export { respond }
